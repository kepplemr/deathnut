"""
This module assists in the generation of env-specific OpenAPI formatted Swagger docs.
Once the large base template is created (today manually, soon by pulling the json generated by 
flask), generally there are only a few line changes per env. Typically the cloud endpoint hostname, 
ingress IP address, and security configurations will change.
An example invocation:
python3.7 generate_openapi/generate_configs.py -b resources/template.yaml \
    -o resources/overrides.yaml \
    -p tmp_test_output
Example Arguments:
resources/template.yaml - large OpenAPI Swagger spec file containing endpoint specifications,
    marshalling information, etc.
    (https://github.com/cephalo-ai/cassava/blob/master/deploy/openapi.template.yaml)
resources/overrides.yaml - small YAML list of env-specific overrides to the base templace.
    (https://github.com/cephalo-ai/cassava/blob/master/deploy/openapi.overrides.yaml)
tmp_test_output - desired output directory for the resulting generated .yaml config files. If no
    path is specified, the generated confs will be output to the pwd.
"""
import argparse
import copy

import yaml

# support python2 & 3
try:
    from collections.abc import Mapping
except ImportError:
    from collections import Mapping


def dict_merge(dct, merge_dct, merge_lists=False):
    """
    This function recursively merges two dictionaries. 
    It handles nested dicts, updating and adding anything merge_dct contains without wiping what was
    in dct.
    The point to watch for is list merging, particularly when merging lists of dictionaries. Since 
    these dict elements are not hashable the way a string key is, we have to handle them 
    differently. The default behavior is to replace the dct list with the list in merge_dct, but 
    passing the merge_lists flag will result in the lists under a shared key to be combined instead.
    Note: even if we made a hashable dict class (easy enought), obviously updating one key/value
    would result in a new hash. This would make the behavior of this function more complicated; I 
    think it's better not to try to be too smart here. 
    Parameters
    ----------
    dct: dict
        The dict that will be modified after merging in merge_dct
    merge_dct : dict
        This dict will be merged into dct.
    merge_lists : boolean
        If true, keys with type(list) values will be merged together. This behavior is disabled by
        default. 
    """
    for key, val in merge_dct.items():
        if (key in dct and isinstance(dct[key], dict) and isinstance(merge_dct[key], Mapping)):
            dict_merge(dct[key], merge_dct[key])
        elif isinstance(val, list) and merge_lists:
            dct[key] = (dct.get(key, []) + val)
        else:
            dct[key] = merge_dct[key]


def output_conf(filename, output_dict, path_prefix):
    yaml.emitter.Emitter.process_tag = lambda *args: None
    with open('/'.join([path_prefix, filename]), 'w') as outfile:
        yaml.dump(output_dict, outfile, default_flow_style=False)


def generate_yaml_confs(base_template_filename, overrides_filename, path_prefix='.', merge_lists=False):
    """
    This function recursively merges two dictionaries. 
    Parameters
    ----------
    base_template_filename: str
        Base OpenAPI template file we'll apply env-specific overrides to.
    overrides_filename : str
        Overrides file containing just the env-specific differences from the base.
    path_prefix : str
        If provided, the directory where we'll output the env-specific yaml files designed in the
        overrides file. If nothing is provided, they will be output in the current directory. Paths
        can be relative, ex: 'tmp_output' or absolute, ex: '/tmp/tmp_output'.
    merge_lists: bool
        If True, keys with list values will be combined together, If False (default), the override
        list will completely replace the original. 
    """
    base_template_dict = {}
    with open(base_template_filename, 'r') as cfg_f:
        base_template_dict = dict(**yaml.safe_load(cfg_f))
    with open(overrides_filename, 'r') as cfg_f:
        for yaml_dict in list(yaml.safe_load_all(cfg_f)):
            temp = copy.deepcopy(base_template_dict)
            dict_merge(temp, yaml_dict, merge_lists)
            output_conf(temp.pop('filename'), dict(
                sorted(temp.items())), path_prefix)


def main():
    parser = argparse.ArgumentParser(
        description='YAML file generation utility')
    parser.add_argument('-b', '--base', type=str, required=True,
                        help='base YAML filename to inherit from')
    parser.add_argument('-o', '--overrides', type=str,
                        required=True, help='template overrides file')
    parser.add_argument('-p', '--path', type=str,
                        help='output path for generated confs (default is pwd)', default='.')
    parser.add_argument('-m', '--merge-lists', action='store_true')
    args = parser.parse_args()
    generate_yaml_confs(args.base, args.overrides, args.path, args.merge_lists)


if __name__ == "__main__":
    main()